### 01 关于Redisson
Redisson是用于springboot操作redis的常用组件包。
>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。

### 02 开发流程
#### 01 cache接口
一个标准的redis缓存接口，需要实现以下功能：
1. 缓存的写入
2. 缓存的读取
3. 缓存的删除
4. 对键的新建
由此，我们可以实现一个最基本的redis操作接口：
```java
package cn.foreveryang.my12306.common.cache;  
  
  
import jakarta.validation.constraints.NotBlank;  
import jakarta.validation.constraints.NotNull;  
  
import java.util.Collection;  
  
public interface Cache {  
  
    /**  
     * 获取缓存  
     */  
    <T> T get(@NotBlank String key, Class<T> clazz);  
  
  
    /**  
     * 放入缓存  
     */  
    void put(@NotBlank String key, Object value);  
  
    /**  
     * 如果 keys 全部不存在，则新增，返回 true，反之 false  
     */    Boolean putIfAllAbsent(@NotNull Collection<String> keys);  
  
    /**  
     * 删除缓存  
     */  
    Boolean delete(@NotBlank String key);  
  
    /**  
     * 删除 keys，返回删除数量  
     */  
    Long delete(@NotNull Collection<String> keys);  
  
    /**  
     * 判断 key 是否存在  
     */  
    Boolean hasKey(@NotBlank String key);  
  
    /**  
     * 获取缓存组件实例  
     */  
    Object getInstance();  
      
}
```
但是，我们不难发现，如果仅仅使用这几个基本方法，在实际应用中往往会发生许多大大小小的问题。
例如：
##### 1. 泛型类型安全问题
```java
// 当前设计需要传递 Class<T> 参数
<T> T get(@NotBlank String key, Class<T> clazz);

// 缺点：运行时类型转换，可能抛出 ClassCastException
Object cachedObj = cache.get("user:123", Object.class);
// 如果实际存储的是 String，但期望是 User，可能出错
```
##### 2. 缺少超时控制机制
```java
// 当前接口没有内置超时参数
void put(@NotBlank String key, Object value);

// 缺点：无法为不同缓存项设置不同的过期时间
// 需要额外方法或实现类来支持超时控制
```
##### 3. 错误处理机制不完善
```java
// 接口方法没有声明可能抛出的异常
<T> T get(@NotBlank String key, Class<T> clazz);
void put(@NotBlank String key, Object value);

// 缺点：使用者不清楚可能遇到的异常情况
// 如：网络异常、序列化异常等
```
##### 4. 缓存一致性保障不足
```java
// 缺少原子操作支持
Boolean putIfAllAbsent(@NotNull Collection<String> keys);

// 缺点：虽然有批量操作，但缺少更复杂的事务性操作
// 如：缓存更新与数据库更新的原子性保证
```
#### 02 对cache的完善
为了解决上述的种种问题，我们引入更完善的缓存操作接口。
```java
package cn.foreveryang.my12306.common.cache;  
  
import cn.foreveryang.my12306.common.cache.core.CacheGetFilter;  
import cn.foreveryang.my12306.common.cache.core.CacheGetIfAbsent;  
import cn.foreveryang.my12306.common.cache.core.CacheLoader;  
import jakarta.validation.constraints.NotBlank;  
import jakarta.validation.constraints.NotNull;  
  
import org.redisson.api.RBloomFilter;  
  
import java.util.concurrent.TimeUnit;  
  
  
  
public interface DistributedCache extends Cache{  
  
    /**  
     * 获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     */  
    <T> T get(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoder, long timeout);  
  
    /**  
     * 获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     */  
    <T> T get(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoder, long timeout, TimeUnit timeUnit);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存击穿、缓存雪崩场景，适用于不被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存击穿、缓存雪崩场景，适用于不被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，适用于被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, RBloomFilter<String> bloomFilter);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，适用于被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit, RBloomFilter<String> bloomFilter);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，并通过 {@link CacheGetFilter} 解决布隆过滤器无法删除问题，适用于被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，并通过 {@link CacheGetFilter} 解决布隆过滤器无法删除问题，适用于被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit, RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，并通过 {@link CacheGetFilter} 解决布隆过滤器无法删除问题，适用于被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout,  
                  RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter, CacheGetIfAbsent<String> cacheGetIfAbsent);  
  
    /**  
     * 以一种"安全"的方式获取缓存，如查询结果为空，调用 {@link CacheLoader} 加载缓存  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，并通过 {@link CacheGetFilter} 解决布隆过滤器无法删除问题，适用于被外部直接调用的接口  
     */  
    <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit,  
                  RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter, CacheGetIfAbsent<String> cacheGetIfAbsent);  
  
    /**  
     * 放入缓存，自定义超时时间  
     */  
    void put(@NotBlank String key, Object value, long timeout);  
  
    /**  
     * 放入缓存，自定义超时时间  
     */  
    void put(@NotBlank String key, Object value, long timeout, TimeUnit timeUnit);  
  
    /**  
     * 放入缓存，自定义超时时间  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，适用于被外部直接调用的接口  
     */  
    void safePut(@NotBlank String key, Object value, long timeout, RBloomFilter<String> bloomFilter);  
  
    /**  
     * 放入缓存，自定义超时时间，并将 key 加入步隆过滤器。极大概率通过此方式防止：缓存穿透、缓存击穿、缓存雪崩  
     * 通过此方式防止程序中可能出现的：缓存穿透、缓存击穿以及缓存雪崩场景，需要客户端传递布隆过滤器，适用于被外部直接调用的接口  
     */  
    void safePut(@NotBlank String key, Object value, long timeout, TimeUnit timeUnit, RBloomFilter<String> bloomFilter);  
  
    /**  
     * 统计指定 key 的存在数量  
     */  
    Long countExistingKeys(@NotNull String... keys);  
      
      
}
```
##### 关于cacheloader
```java
package cn.foreveryang.my12306.common.cache.core;  
  
@FunctionalInterface  
public interface CacheLoader<T> {  
    T load();  
}
```
如上，我们将`CacheLoader<T>`定义为一个函数式接口。
 > 函数式接口是 Java 8 引入的一种接口，它只包含一个抽象方法。函数式接口的存在是为了支持 Lambda 表达式，使得我们可以使用更简洁、更灵活的方式编写匿名函数。
#### 03 具体实现
我们定义一个实现类实现该接口的所有方法。
```java
package cn.foreveryang.my12306.common.cache;  
  
import cn.foreveryang.my12306.common.base.Singleton;  
import cn.foreveryang.my12306.common.cache.config.RedisDistributedProperties;  
import cn.foreveryang.my12306.common.cache.core.CacheGetFilter;  
import cn.foreveryang.my12306.common.cache.core.CacheGetIfAbsent;  
import cn.foreveryang.my12306.common.cache.core.CacheLoader;  
import cn.foreveryang.my12306.common.cache.toolkit.CacheUtil;  
import cn.foreveryang.my12306.common.toolkit.FastJson2Util;  
import com.alibaba.fastjson2.JSON;  
import jakarta.validation.constraints.NotBlank;  
import jakarta.validation.constraints.NotNull;  
import lombok.RequiredArgsConstructor;  
import org.assertj.core.util.Lists;  
import org.redisson.api.RBloomFilter;  
import org.redisson.api.RLock;  
import org.redisson.api.RedissonClient;  
import org.springframework.core.io.ClassPathResource;  
import org.springframework.data.redis.core.StringRedisTemplate;  
import org.springframework.data.redis.core.script.DefaultRedisScript;  
import org.springframework.scripting.support.ResourceScriptSource;  
import org.springframework.stereotype.Component;  
  
import java.util.Collection;  
import java.util.Optional;  
import java.util.concurrent.TimeUnit;  
  
@Component  
@RequiredArgsConstructor  
public class StringRedisTemplateProxy implements DistributedCache{  
    private final StringRedisTemplate stringRedisTemplate;  
    private final RedisDistributedProperties redisProperties;  
    private final RedissonClient redissonClient;  
      
    private static final String LUA_PUT_IF_ALL_ABSENT_SCRIPT_PATH = "lua/putIfAllAbsent.lua";  
    private static final String SAFE_GET_DISTRIBUTED_LOCK_KEY_PREFIX = "safe_get_distributed_lock_get:";  
  
    @Override  
    public <T> T get(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout) {  
        return get(key, clazz, cacheLoader, timeout, redisProperties.getValueTimeUnit());  
    }  
  
    @Override  
    public <T> T get(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit) {  
        T result = get(key, clazz);  
        if (!CacheUtil.isNullOrBlank(result)) {  
            return result;  
        }  
        return loadAndSet(key, cacheLoader, timeout, timeUnit, false, null);  
    }  
  
    @Override  
    public <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout) {  
        return safeGet(key, clazz, cacheLoader, timeout, redisProperties.getValueTimeUnit());  
    }  
  
    @Override  
    public <T> T safeGet(@NotBlank String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit) {  
        return safeGet(key, clazz, cacheLoader, timeout, timeUnit, null);  
    }  
  
    @Override  
    public <T> T safeGet(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, RBloomFilter<String> bloomFilter) {  
        return safeGet(key, clazz, cacheLoader, timeout, bloomFilter, null, null);  
    }  
  
    @Override  
    public <T> T safeGet(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit, RBloomFilter<String> bloomFilter) {  
        return safeGet(key, clazz, cacheLoader, timeout, timeUnit, bloomFilter, null, null);  
    }  
  
    @Override  
    public <T> T safeGet(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter) {  
        return safeGet(key, clazz, cacheLoader, timeout, redisProperties.getValueTimeUnit(), bloomFilter, cacheCheckFilter, null);  
    }  
  
    @Override  
    public <T> T safeGet(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit, RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter) {  
        return safeGet(key, clazz, cacheLoader, timeout, timeUnit, bloomFilter, cacheCheckFilter, null);  
    }  
  
    @Override  
    public <T> T safeGet(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout,  
                         RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheCheckFilter, CacheGetIfAbsent<String> cacheGetIfAbsent) {  
        return safeGet(key, clazz, cacheLoader, timeout, redisProperties.getValueTimeUnit(), bloomFilter, cacheCheckFilter, cacheGetIfAbsent);  
    }  
  
    @Override  
    public <T> T safeGet(String key, Class<T> clazz, CacheLoader<T> cacheLoader, long timeout,  
                         TimeUnit timeUnit, RBloomFilter<String> bloomFilter, CacheGetFilter<String> cacheGetFilter, CacheGetIfAbsent<String> cacheGetIfAbsent) {  
        T result = get(key, clazz);  
        // 缓存结果不等于空或空字符串直接返回；通过函数判断是否返回空，为了适配布隆过滤器无法删除的场景；两者都不成立，判断布隆过滤器是否存在，不存在返回空  
        if (!CacheUtil.isNullOrBlank(result)  
                || Optional.ofNullable(cacheGetFilter).map(each -> each.filter(key)).orElse(false)  
                || Optional.ofNullable(bloomFilter).map(each -> !each.contains(key)).orElse(false)) {  
            return result;  
        }  
        RLock lock = redissonClient.getLock(SAFE_GET_DISTRIBUTED_LOCK_KEY_PREFIX + key);  
        lock.lock();  
        try {  
            // 双重判定锁，减轻获得分布式锁后线程访问数据库压力  
            if (CacheUtil.isNullOrBlank(result = get(key, clazz))) {  
                // 如果访问 cacheLoader 加载数据为空，执行后置函数操作  
                if (CacheUtil.isNullOrBlank(result = loadAndSet(key, cacheLoader, timeout, timeUnit, true, bloomFilter))) {  
                    Optional.ofNullable(cacheGetIfAbsent).ifPresent(each -> each.execute(key));  
                }  
            }  
        } finally {  
            lock.unlock();  
        }  
        return result;  
    }  
  
    @Override  
    public void put(String key, Object value, long timeout) {  
        put(key, value, timeout, redisProperties.getValueTimeUnit());  
    }  
  
    @Override  
    public void put(String key, Object value, long timeout, TimeUnit timeUnit) {  
        String actual = value instanceof String ? (String) value : JSON.toJSONString(value);  
        stringRedisTemplate.opsForValue().set(key, actual, timeout, timeUnit);  
    }  
  
    @Override  
    public void safePut(String key, Object value, long timeout, RBloomFilter<String> bloomFilter) {  
        safePut(key, value, timeout, redisProperties.getValueTimeUnit(), bloomFilter);  
    }  
  
    @Override  
    public void safePut(String key, Object value, long timeout, TimeUnit timeUnit, RBloomFilter<String> bloomFilter) {  
        put(key, value, timeout, timeUnit);  
        if (bloomFilter != null) {  
            bloomFilter.add(key);  
        }  
    }  
  
    @Override  
    public Long countExistingKeys(@NotNull String... keys) {  
        return stringRedisTemplate.countExistingKeys(Lists.newArrayList(keys));  
    }  
  
    @Override  
    public <T> T get(String key, Class<T> clazz) {  
        String value = stringRedisTemplate.opsForValue().get(key);  
        if (String.class.isAssignableFrom(clazz)) {  
            return (T) value;  
        }  
        return JSON.parseObject(value, FastJson2Util.buildType(clazz));  
    }  
  
    @Override  
    public void put(String key, Object value) {  
        put(key, value, redisProperties.getValueTimeout());  
    }  
  
    @Override  
    public Boolean putIfAllAbsent(@NotNull Collection<String> keys) {  
        DefaultRedisScript<Boolean> actual = Singleton.get(LUA_PUT_IF_ALL_ABSENT_SCRIPT_PATH, () -> {  
            DefaultRedisScript redisScript = new DefaultRedisScript();  
            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(LUA_PUT_IF_ALL_ABSENT_SCRIPT_PATH)));  
            redisScript.setResultType(Boolean.class);  
            return redisScript;  
        });  
        Boolean result = stringRedisTemplate.execute(actual, Lists.newArrayList(keys), redisProperties.getValueTimeout().toString());  
        return result != null && result;  
    }  
  
    @Override  
    public Boolean delete(String key) {  
        return stringRedisTemplate.delete(key);  
    }  
  
    @Override  
    public Long delete(Collection<String> keys) {  
        return stringRedisTemplate.delete(keys);  
    }  
  
    @Override  
    public Boolean hasKey(String key) {  
        return stringRedisTemplate.hasKey(key);  
    }  
  
    @Override  
    public Object getInstance() {  
        return stringRedisTemplate;  
    }  
  
    private <T> T loadAndSet(String key, CacheLoader<T> cacheLoader, long timeout, TimeUnit timeUnit, boolean safeFlag, RBloomFilter<String> bloomFilter) {  
        T result = cacheLoader.load();  
        if (CacheUtil.isNullOrBlank(result)) {  
            return result;  
        }  
        if (safeFlag) {  
            safePut(key, result, timeout, timeUnit, bloomFilter);  
        } else {  
            put(key, result, timeout, timeUnit);  
        }  
        return result;  
    }  
    }
```
##### lua脚本
```lua
--[[KEYS 全部不存在，创建并返回 true，反之返回空]]  
  
for i, v in ipairs(KEYS) do  
    if (redis.call('exists', v) == 1) then  
        return nil;  
    end  
end  
for i, v in ipairs(KEYS) do  
    redis.call('set', v, 'default');  
    redis.call('pexpire', v, ARGV[1]);  
end  
return true;
```
在第一个for循环中，我们进行了键是否存在的判断。
如果所有键都不存在，我们才进行对键进行新建。
>使用Lua脚本的关键优势是原子性：
> 1. 整个脚本作为一个原子操作执行
> 2. 不会被其他客户端的请求打断
> 3. 避免了竞态条件
#### 04 应用与分析
![](../../imgs/Pasted%20image%2020250910171612.png)
面对这种高并发，多复用的场景。
我们需要使用redis进行数据的存储和查询。
service层实现类如下
```java
private final DistributedCache distributedCache;
@Override  
public List<StationQueryRespDTO> listAllTrainStationQuery() {  
    return distributedCache.safeGet(  
            STATION_ALL,  
            List.class,  
            () -> BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class),  
            ADVANCE_TICKET_DAY,  
            TimeUnit.DAYS  
    );  
}
```
如上，我们调用了`safeGet()`方法，并传入了相应的参数。
##### 详解
```java
@Override
public List<StationQueryRespDTO> listAllTrainStationQuery() {
    return distributedCache.safeGet(
            STATION_ALL,                                    // 缓存键
            List.class,                                     // 返回类型
            () -> BeanUtil.convert(stationMapper.selectList(Wrappers.emptyWrapper()), StationQueryRespDTO.class), // 缓存加载器
            ADVANCE_TICKET_DAY,                             // 超时时间
            TimeUnit.DAYS                                   // 时间单位
    );
}
```
#### 补充
##### BeanUtil
```java
package cn.foreveryang.my12306.common.toolkit;  
  
import com.github.dozermapper.core.DozerBeanMapperBuilder;  
import com.github.dozermapper.core.Mapper;  
import com.github.dozermapper.core.loader.api.BeanMappingBuilder;  
import lombok.NoArgsConstructor;  
  
import java.lang.reflect.Array;  
import java.util.*;  
  
import static com.github.dozermapper.core.loader.api.TypeMappingOptions.mapEmptyString;  
import static com.github.dozermapper.core.loader.api.TypeMappingOptions.mapNull;  
  
@NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)  
public class BeanUtil {  
  
    protected static Mapper BEAN_MAPPER_BUILDER;  
  
    static {  
        BEAN_MAPPER_BUILDER = DozerBeanMapperBuilder.buildDefault();  
    }  
  
    /**  
     * 属性复制  
     *  
     * @param source 数据对象  
     * @param target 目标对象  
     * @param <T>  
     * @param <S>  
     * @return 转换后对象  
     */  
    public static <T, S> T convert(S source, T target) {  
        Optional.ofNullable(source)  
                .ifPresent(each -> BEAN_MAPPER_BUILDER.map(each, target));  
        return target;  
    }  
  
    /**  
     * 复制单个对象  
     *  
     * @param source 数据对象  
     * @param clazz  复制目标类型  
     * @param <T>  
     * @param <S>  
     * @return 转换后对象  
     */  
    public static <T, S> T convert(S source, Class<T> clazz) {  
        return Optional.ofNullable(source)  
                .map(each -> BEAN_MAPPER_BUILDER.map(each, clazz))  
                .orElse(null);  
    }  
  
    /**  
     * 复制多个对象  
     *  
     * @param sources 数据对象  
     * @param clazz   复制目标类型  
     * @param <T>  
     * @param <S>  
     * @return 转换后对象集合  
     */  
    public static <T, S> List<T> convert(List<S> sources, Class<T> clazz) {  
        return Optional.ofNullable(sources)  
                .map(each -> {  
                    List<T> targetList = new ArrayList<T>(each.size());  
                    each.stream()  
                            .forEach(item -> targetList.add(BEAN_MAPPER_BUILDER.map(item, clazz)));  
                    return targetList;  
                })  
                .orElse(null);  
    }  
  
    /**  
     * 复制多个对象  
     *  
     * @param sources 数据对象  
     * @param clazz   复制目标类型  
     * @param <T>  
     * @param <S>  
     * @return 转换后对象集合  
     */  
    public static <T, S> Set<T> convert(Set<S> sources, Class<T> clazz) {  
        return Optional.ofNullable(sources)  
                .map(each -> {  
                    Set<T> targetSize = new HashSet<T>(each.size());  
                    each.stream()  
                            .forEach(item -> targetSize.add(BEAN_MAPPER_BUILDER.map(item, clazz)));  
                    return targetSize;  
                })  
                .orElse(null);  
    }  
  
    /**  
     * 复制多个对象  
     *  
     * @param sources 数据对象  
     * @param clazz   复制目标类型  
     * @param <T>  
     * @param <S>  
     * @return 转换后对象集合  
     */  
    public static <T, S> T[] convert(S[] sources, Class<T> clazz) {  
        return Optional.ofNullable(sources)  
                .map(each -> {  
                    @SuppressWarnings("unchecked")  
                    T[] targetArray = (T[]) Array.newInstance(clazz, sources.length);  
                    for (int i = 0; i < targetArray.length; i++) {  
                        targetArray[i] = BEAN_MAPPER_BUILDER.map(sources[i], clazz);  
                    }  
                    return targetArray;  
                })  
                .orElse(null);  
    }  
  
    /**  
     * 拷贝非空且非空串属性  
     *  
     * @param source 数据源  
     * @param target 指向源  
     */  
    public static void convertIgnoreNullAndBlank(Object source, Object target) {  
        DozerBeanMapperBuilder dozerBeanMapperBuilder = DozerBeanMapperBuilder.create();  
        Mapper mapper = dozerBeanMapperBuilder.withMappingBuilders(new BeanMappingBuilder() {  
  
            @Override  
            protected void configure() {  
                mapping(source.getClass(), target.getClass(), mapNull(false), mapEmptyString(false));  
            }  
        }).build();  
        mapper.map(source, target);  
    }  
  
    /**  
     * 拷贝非空属性  
     *  
     * @param source 数据源  
     * @param target 指向源  
     */  
    public static void convertIgnoreNull(Object source, Object target) {  
        DozerBeanMapperBuilder dozerBeanMapperBuilder = DozerBeanMapperBuilder.create();  
        Mapper mapper = dozerBeanMapperBuilder.withMappingBuilders(new BeanMappingBuilder() {  
  
            @Override  
            protected void configure() {  
                mapping(source.getClass(), target.getClass(), mapNull(false));  
            }  
        }).build();  
        mapper.map(source, target);  
    }  
}
```
